...menustart

 - [2](#c81e728d9d4c2f636f067f89cc14862c)
     - [2.2.3 语法分析树 parse tree](#1c1103b7cf6ef2d7187e2af20e737f18)
     - [2.2.4 二义性](#4fc16bc8643d7d323084092c6edcb13e)
     - [2.2.5 运算符的结合性](#206dbde1846f8503c61c705fda9367b3)
     - [2.2.6 运算符的优先级](#b9bd154f2f24f4de761a2c5c979d6a0d)
     - [2.3 语法制导翻译](#16499a85259e66bcce718661e4fb5392)
     - [2.4 语法分析](#afd7adba5235839e613145e93779d816)
         - [2.4.1 自顶向下分析方法](#e86b1d223b805c6988c05790b9070a24)
         - [2.4.2 预测分析法](#64d873364c0ef1d8d66b0c034574ccf1)
         - [2.4.5 左递归](#45a2fcd97ccc94e5d941d6ff0061a3bf)
     - [2.5 简单表达式的翻译器](#4421301821ced2f90bd6a14e54d12a53)
         - [2.5.4 翻译器的简化](#1167fe353876aeb46eac89f506ef1c5f)
     - [2.6 词法分析](#4ab47bf003d890258aee2debca03502f)
         - [2.6.1 踢出空白和注释](#f89a7ff3f83279d87379fbe1a647a2ec)
         - [2.6.2 预读](#8db14144f5b84c3bb05b7055e6672b21)
     - [2.7 符号表](#8ae83720f79e0764eef0ce79c87d3462)
 - [3 Lexical Analysis](#1a7dca2b1698b918edda658b65076d76)
     - [3.1.2 词法单元tokens  模式patterns 词素lexemes](#cf1effdeec844f6b4712bc7ba0969cb6)
     - [3.4.1 状态转换图](#96b2680d20ac47c6ba642d68e43ee952)
     - [3.4.2 保留字 和 标识符的 识别](#76ee5f936ccf5b3960fb370357772f16)
     - [3.4.4 基于状态转换图的 词法分析器的  体系结构](#11e3839155afe5d33a55b59459334dcf)
     - [3.6 有穷自动机](#b93159a6d54bff0f228053fd4fce6789)

...menuend


<h2 id="c81e728d9d4c2f636f067f89cc14862c"></h2>

# 2

<h2 id="1c1103b7cf6ef2d7187e2af20e737f18"></h2>

### 2.2.3 语法分析树 parse tree

<h2 id="4fc16bc8643d7d323084092c6edcb13e"></h2>

### 2.2.4 二义性

<h2 id="206dbde1846f8503c61c705fda9367b3"></h2>

### 2.2.5 运算符的结合性

<h2 id="b9bd154f2f24f4de761a2c5c979d6a0d"></h2>

### 2.2.6 运算符的优先级

 - 创建额外的非终结符，用于对应 优先级层次


<h2 id="16499a85259e66bcce718661e4fb5392"></h2>

## 2.3 语法制导翻译
 
 - 生产式中嵌入 语义动作 semantic action

<h2 id="afd7adba5235839e613145e93779d816"></h2>

## 2.4 语法分析

 1. 自顶向下
    - 容易手工构造
 2. 自底向上
    - 可以处理更多种文法和翻译方案

<h2 id="e86b1d223b805c6988c05790b9070a24"></h2>

### 2.4.1 自顶向下分析方法

 - 一般来说，为一个非终结符 选择产生式是一个 “尝试并犯错” 的过程。
 - 但是 在称为 预测语法分析的特殊情形下 不需要进行回溯。

<h2 id="64d873364c0ef1d8d66b0c034574ccf1"></h2>

### 2.4.2 预测分析法

 - 递归下降分析方法 是一种 自顶向下的语法分析方法，它使用一组递归过程来处理输入
    - 每个非终结符 都有一个 相关联的过程
 - 预测分析法 predictive parsing 是 递归下降分析法的一种 简单形式
    - 每个非终结符 对应的过程中的控制流 可以由 lookahead 符号 无二义地确定
    - 如果有两个产生式 A→α, A→β , 如果不考虑ε产生式, 预测分析法要求 FIRST(α) ， FIRST(β) 不相交.
        - FIRST 可以选择产生式

<h2 id="45a2fcd97ccc94e5d941d6ff0061a3bf"></h2>

### 2.4.5 左递归

 - 左递归会导致 递归下降语法分析器 进入无限循环
 - 可以改写成 右递归
    - 对包含 左结合运算符(i.e.+ -) 的表达式 的翻译 会变得较为困难。

<h2 id="4421301821ced2f90bd6a14e54d12a53"></h2>

## 2.5 简单表达式的翻译器

 - AST 是设计 翻译器的 一个很好的起点
    - AST 简称 语法树 syntax tree， 某种程度上和 语法分析树相似
    - 树中没有 对应于 expr → term 这样的单产生式 的“辅助”节点
    - 也没有对应于 ε产生式 ( rest→ε ) 的节点

<h2 id="1167fe353876aeb46eac89f506ef1c5f"></h2>

### 2.5.4 翻译器的简化

 - expr → term 把 term 这样的 展开到 expr
 - 某些递归调用， 替换为 迭代
    - 如 尾递归


<h2 id="4ab47bf003d890258aee2debca03502f"></h2>

## 2.6 词法分析

<h2 id="f89a7ff3f83279d87379fbe1a647a2ec"></h2>

### 2.6.1 踢出空白和注释

<h2 id="8db14144f5b84c3bb05b7055e6672b21"></h2>

### 2.6.2 预读

<h2 id="8ae83720f79e0764eef0ce79c87d3462"></h2>

## 2.7 符号表

 - symbol table list

<h2 id="1a7dca2b1698b918edda658b65076d76"></h2>

# 3 Lexical Analysis

 - 词法分析器，可以分为 两个步骤
    1. 扫描阶段
        - 一些不需要生成词法单元的 简单处理， 比如 删除注释，将多个连续空白字符 压缩成一个字符
    2. 词法分析阶段
        - 处理 扫描阶段的输出，并生成词法单元
    
<h2 id="cf1effdeec844f6b4712bc7ba0969cb6"></h2>

### 3.1.2 词法单元tokens  模式patterns 词素lexemes

 - examle 

词法单元 |  非正式 模式描述 | 词素示例
--- | --- | ---
if | 字符 i,f  | if
else | 字符 e,l,s,e | else 
comparison | < , > , <= , >=  , == , != | <=, !=
id | 字母开头 的字母/数字串  | pi, score, D2
number | 任何数字常量 | 3.14159 , 0.6
literal | 两个 “ 之间除“ 以外的 任何字符 | "core dumped"


- 很多程序设计语言中， 下面的类别 覆盖了大部分 或 所有的词法单元
    1. 每个关键字有一个词法单元
        - 一个关键字的 pattern 就是该关键字本身
    2. 表示运算符的词法单元
        - 可以是 单个运算符，
        - 也可以是 像上面的comparison 那样 表示一类运算符
    3. 一个表示所有 标识符的词法单元 id
    4. 一个或多个表示常量的词法单元
        - 比如数字， 和 字面值 字符串
    5. 每一个标点 有一个词法单元， 
        - 比如 左右括号，逗号， 分号

<h2 id="96b2680d20ac47c6ba642d68e43ee952"></h2>

### 3.4.1 状态转换图

 - 构造词法分析器的 一个中间步骤
 - 将pattern 转换成 具有特定风格的流图， 称为 “状态转换图”。
 - 可以使用 自动化的方法，根据一组正则表达式集合  构造出 状态转换图。
 - 接受状态（最终状态） 可能需要回退。

<h2 id="76ee5f936ccf5b3960fb370357772f16"></h2>

### 3.4.2 保留字 和 标识符的 识别

 - 有两种方法
    1. 初始化时 ， 将各个保留字 填入 symbol table中
    2. 为每个关键字 建立单独的 状态转换图
        - 需要一步回退，最 结束检测

<h2 id="11e3839155afe5d33a55b59459334dcf"></h2>

### 3.4.4 基于状态转换图的 词法分析器的  体系结构
 
 - 如何将各个 状态转换图的处理代码 集成到 词法分析器？
    1. 顺序地尝试各个 词法单元的状态转换图
        - 调用 fail() 会启动下一个状态转换图
    2. 并行地 运行各个状态转换图，将下一个输入字符，提供给 所有的状态转换图。
        - 最长匹配策略
    3. 更好的办法： 合并所有状态转换图为 一个图
        - 依然使用 最长匹配策略

<h2 id="b93159a6d54bff0f228053fd4fce6789"></h2>

## 3.6 有穷自动机

 - 表示
    1. 转换图
    2. 转换表

 - NFA/DFA
    - NFA 抽象地表示了 ，用来识别**某个语言中的串**的 算法
    - DFA 是一个 简单具体的识别**串**的算法
 - 每个正则表达式 或 NFA 都可以被转变成为 一个接受相同语言的 DFA.

 - 模拟一个DFA
    - 输入: 
        - 一个以 文件结束符 eof 结尾的 字符串 x
        - DFA D 的 开始状态为 s0
        - D 的 接受状态集为 F 
        - 转换函数为 move 
    - 输出 
        - 如果 D 接受 x， 则回答 yes, 否则，回答 no

```c
s = s0
c = nextChar()
while ( c!=eof )  {
    s = move(s,c) ;
    c = nextChar() ;     
}
if ( s in F ) return "yes" ;
else return "no" ;
```






  










