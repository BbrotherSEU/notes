...menustart

 - [8 我是Makefile](#0a90d03ec88e2482664b9f0c6adc6631)
     - [8.2 基本概念](#4fd59a44db61539acebb9e94ce703e21)
         - [8.2.2 目标,条件和命令](#3dae9c4e7839d0a98e1a387f3f23ce72)
         - [8.2.4 工作方式](#fe0198d3d2568f2848eb86c256650721)
         - [8.2.5 基本语法](#851458679c96a263b7e9f5a9711397c8)
     - [8.3 认识规则](#64006e68160fb1df531eaa4e9d761742)
         - [8.3.3 变量](#b293d527ac15c52b704e3092f19ec9f1)

...menuend


<h2 id="0a90d03ec88e2482664b9f0c6adc6631"></h2>

# 8 我是Makefile

 - make
    - make 会一次查找 GNUmakefile, makefile, Makefile 
        - 也可以使用 -f 指定一个工作文件
    - `-d` 参数用于调试 Makefile

<h2 id="4fd59a44db61539acebb9e94ce703e21"></h2>

## 8.2 基本概念

<h2 id="3dae9c4e7839d0a98e1a387f3f23ce72"></h2>

### 8.2.2 目标,条件和命令

```
# 目标 : 条件
#    命令
all: TinyEdit   

TinyEdit: main.o line.o ...
    ...
main.o : main.c line.h buffer.h tedef.h
    cc -c -o main.o main.c    
```


 - 目标可以作为参数，直接传给 make 
    - i.e. `make main.o`
    - 默认执行 make all

<h2 id="fe0198d3d2568f2848eb86c256650721"></h2>

### 8.2.4 工作方式

 - 一个规模宏大的项目，比如 Linux 内核，源码文件数量数十万计，编译一次内核大概需要几十分钟甚至数小时
 - 如果每做一点修改，都要编译这么久，那简直就是灾难
 - make 解决这个问题的方法 就是哪个文件进行了修改 就只编译它
    - make 会依次把所有的目标，以及它们所对应的依赖， 进行时间戳(文件最后的修改时间)的对比。
    - 当发现某一个目标 比它的某些依赖的时间戳小的时候，就重新生成它。


<h2 id="851458679c96a263b7e9f5a9711397c8"></h2>

### 8.2.5 基本语法

 - Makefile的基本语法是:

```
目标1 目标2 目标3 ... : 条件1 条件2 条件3 ...
    命令 1
    命令 2
    命令 3
    ...
```


 - 至少一个目标
 - 0个或 多个条件
    - 如果 没有给定条件， 只有 目标文件不存在时， 才会执行相应的命令去生成目标
 - 每个命令 必须以 制表符 `Tab` 开头
    - 如果在非命令行上不慎输入了 Tab的话，它之后的内容多数情况下会被当作命令来解释
 - 注释
    - `#` 开始的部分为注释
    - 不过切记 Tab的问题，  只要在 Tab后， 就会被作为命令解释， 包括 `#` 后面的内容
 - Makefile 支持 折行 
    - 在行尾 使用 `\` 


<h2 id="64006e68160fb1df531eaa4e9d761742"></h2>

## 8.3 认识规则

<h2 id="b293d527ac15c52b704e3092f19ec9f1"></h2>

### 8.3.3 变量

 - 现在需要给 生成的程序加入调试信息， 以便在发现bug


